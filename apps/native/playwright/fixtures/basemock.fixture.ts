/**
 * BaseMock Fixture for Playwright Tests
 *
 * Provides programmatic access to BaseMock server for testing
 * connected flows like sessions and messages.
 */

import { test as base, expect, Page } from '@playwright/test';

// We need to spawn basemock as a child process since it's a separate package
// that runs as a standalone server
import { spawn, ChildProcess, execFileSync } from 'child_process';
import { io, Socket } from 'socket.io-client';
import path from 'path';

// =============================================================================
// Types
// =============================================================================

export interface BaseMockApi {
  /** The URL to connect to basemock */
  url: string;
  /** The shared secret for authentication */
  secret: string;
  /** Port number the server is running on */
  port: number;
  /** Helper to add a workstation in the UI pointing to basemock */
  addWorkstationViaUI: (page: Page, name?: string) => Promise<void>;
  /** Create a test socket client connected to basemock */
  createClient: () => Promise<Socket>;
}

interface BaseMockFixtures {
  basemock: BaseMockApi;
}

// =============================================================================
// Fixture Implementation
// =============================================================================

/**
 * Wait for basemock server to be ready by attempting to connect
 */
async function waitForServer(url: string, secret: string, timeout = 30000): Promise<void> {
  const start = Date.now();

  while (Date.now() - start < timeout) {
    try {
      const socket = io(url, {
        transports: ['websocket'],
        reconnection: false,
        timeout: 2000,
        auth: { secret },
      });

      await new Promise<void>((resolve, reject) => {
        const timer = setTimeout(() => {
          socket.close();
          reject(new Error('Connection timeout'));
        }, 3000);

        socket.on('connect', () => {
          clearTimeout(timer);
          // Send ping to verify server is responsive
          socket.emit('ping', (response: { pong?: boolean }) => {
            socket.close();
            if (response?.pong) {
              resolve();
            } else {
              reject(new Error('Invalid ping response'));
            }
          });
        });

        socket.on('connect_error', (err) => {
          clearTimeout(timer);
          socket.close();
          reject(err);
        });
      });

      return; // Server is ready
    } catch {
      // Wait a bit before retrying
      await new Promise((r) => setTimeout(r, 500));
    }
  }

  throw new Error(`BaseMock server not ready after ${timeout}ms`);
}

/**
 * Kill any processes using the specified port (test cleanup only)
 * Port is a trusted numeric value generated by the test fixture.
 */
function killProcessOnPort(port: number): void {
  try {
    // Use lsof to find PIDs on the port (macOS/Linux)
    const output = execFileSync('lsof', ['-ti', `:${port}`], { encoding: 'utf8', stdio: ['pipe', 'pipe', 'ignore'] });
    const pids = output.trim().split('\n').filter(Boolean);
    for (const pid of pids) {
      try {
        process.kill(parseInt(pid, 10), 'SIGKILL');
      } catch {
        // Process already dead
      }
    }
  } catch {
    // Ignore errors - port might already be free or lsof not found
  }
}

/**
 * Start basemock server as a child process
 */
function startBaseMockServer(port: number, secret: string): ChildProcess {
  // Calculate monorepo root
  const mobileDir = process.cwd();
  const monorepoRoot = mobileDir.endsWith('/apps/mobile')
    ? path.resolve(mobileDir, '../..')
    : mobileDir.replace('/apps/mobile', '');

  const basemockDir = path.join(monorepoRoot, 'apps/basemock');

  // Kill any leftover processes on this port before starting
  killProcessOnPort(port);

  // Spawn tsx directly instead of going through pnpm for more reliable process control
  const child = spawn('npx', ['tsx', 'src/headless.ts', '--port', String(port), '--secret', secret], {
    cwd: basemockDir,
    stdio: ['ignore', 'pipe', 'pipe'],
    detached: true, // Create new process group for reliable cleanup
  });

  // Prevent the child from keeping the parent alive
  child.unref();

  child.stdout?.on('data', (data) => {
    console.log(`[basemock:${port}] ${data.toString().trim()}`);
  });

  child.stderr?.on('data', (data) => {
    console.error(`[basemock:${port} error] ${data.toString().trim()}`);
  });

  return child;
}

/**
 * Kill a process and its process group
 */
function killServerProcess(serverProcess: ChildProcess, port: number): void {
  // First try to kill the process group
  if (serverProcess.pid) {
    try {
      // Kill the entire process group (negative PID)
      process.kill(-serverProcess.pid, 'SIGKILL');
    } catch {
      // If process group kill fails, try direct kill
      try {
        serverProcess.kill('SIGKILL');
      } catch {
        // Process already dead
      }
    }
  }

  // As a fallback, also kill any processes on the port
  killProcessOnPort(port);
}

// =============================================================================
// Exported Test Extension
// =============================================================================

export const test = base.extend<BaseMockFixtures>({
  basemock: async ({}, use, testInfo) => {
    // Use a unique port for each parallel worker to avoid conflicts
    // Spread ports out more to avoid any overlap
    const port = 4000 + (testInfo.parallelIndex || 0) * 10 + Math.floor(Math.random() * 10);
    const secret = `test-secret-${Date.now()}-${testInfo.parallelIndex}-${Math.random().toString(36).slice(2)}`;
    const url = `http://localhost:${port}`;

    // Start basemock server
    const serverProcess = startBaseMockServer(port, secret);

    try {
      // Wait for server to be ready
      await waitForServer(url, secret);

      const api: BaseMockApi = {
        url,
        secret,
        port,

        addWorkstationViaUI: async (page: Page, name?: string) => {
          // Navigate to settings
          await page.locator('[data-testid="settings-button"]').click();
          await expect(page.locator('[data-testid="settings-screen"]')).toBeVisible();

          // Click add workstation button
          await page.locator('[data-testid="add-workstation-button"]').click();

          // Fill in URL
          await page.locator('[data-testid="workstation-url-input"]').fill(url);

          // Fill in secret
          await page.locator('[data-testid="workstation-secret-input"]').fill(secret);

          // Test connection first
          await page.locator('[data-testid="workstation-test-button"]').click();

          // Wait for test to complete (success message)
          await expect(page.locator('text=Connected successfully')).toBeVisible({ timeout: 20000 });

          // Fill in name if provided
          if (name) {
            await page.locator('[data-testid="workstation-name-input"]').fill(name);
          }

          // Save
          await page.locator('[data-testid="workstation-save-button"]').click();

          // Wait for modal to close
          await expect(page.locator('[data-testid="workstation-save-button"]')).not.toBeVisible({ timeout: 5000 });

          // Go back to drawer
          // Click outside settings or use close button
          await page.keyboard.press('Escape');
        },

        createClient: async () => {
          const socket = io(url, {
            transports: ['websocket'],
            reconnection: false,
            auth: { secret },
          });

          await new Promise<void>((resolve, reject) => {
            const timer = setTimeout(() => reject(new Error('Client connection timeout')), 5000);
            socket.on('connect', () => {
              clearTimeout(timer);
              resolve();
            });
            socket.on('connect_error', (err) => {
              clearTimeout(timer);
              reject(err);
            });
          });

          return socket;
        },
      };

      await use(api);
    } finally {
      // Clean up: kill the server process
      killServerProcess(serverProcess, port);
    }
  },
});

export { expect };
