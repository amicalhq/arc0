// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by scripts/generate-embedded-files.ts
// Source: claude-session.js

export const CLAUDE_SESSION_SCRIPT = `#!/usr/bin/env node
/**
 * Arc0 Claude Code Session Hook
 *
 * This script is called by Claude Code on SessionStart, SessionEnd, and PermissionRequest events.
 * It reads session data from stdin and manages session files.
 * Note: CONFIG_DIR is templated during installation by \`arc0 hooks install\`.
 *
 * Stdin payload from Claude Code:
 * {
 *   "session_id": "...",
 *   "transcript_path": "...",
 *   "cwd": "...",
 *   "hook_event_name": "SessionStart" | "SessionEnd" | "PermissionRequest",
 *   "source": "startup" (for start) | "reason": "..." (for end)
 * }
 *
 * For PermissionRequest, additional fields:
 * {
 *   "tool_use_id": "...",
 *   "tool_name": "...",
 *   "tool_input": {...},
 *   "permission_mode": "..."
 * }
 */

const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

const CONFIG_DIR = "__CONFIG_DIR__";
const SESSIONS_DIR = path.join(CONFIG_DIR, "sessions");

/**
 * Get the TTY device for a given PID
 */
function getTtyForPid(pid) {
  try {
    // Works on macOS and Linux
    const result = execSync(\`ps -p \${pid} -o tty=\`, { encoding: "utf-8" }).trim();
    if (result && result !== "?" && result !== "??") {
      // Normalize TTY path
      if (result.startsWith("/dev/")) {
        return result;
      }
      return \`/dev/\${result}\`;
    }
  } catch {
    // Ignore errors
  }
  return null;
}

/**
 * Read all stdin as a string
 */
function readStdin() {
  return new Promise((resolve) => {
    let data = "";
    process.stdin.setEncoding("utf-8");
    process.stdin.on("data", (chunk) => {
      data += chunk;
    });
    process.stdin.on("end", () => {
      resolve(data);
    });
    // Handle case where stdin is already closed
    if (process.stdin.readableEnded) {
      resolve(data);
    }
  });
}

async function handleSessionStart(payload) {
  const sessionId = payload.session_id;
  const cwd = payload.cwd;
  const transcriptPath = payload.transcript_path;

  // Get parent PID (Claude Code process)
  const pid = process.ppid;

  // Get TTY for the process
  const tty = getTtyForPid(pid);

  // Create session file
  const sessionFile = {
    sessionId,
    provider: "claude",
    cwd,
    transcriptPath,
    pid,
    tty,
    startedAt: new Date().toISOString(),
    payload, // raw payload for debugging
  };

  // Ensure sessions directory exists
  if (!fs.existsSync(SESSIONS_DIR)) {
    fs.mkdirSync(SESSIONS_DIR, { recursive: true });
  }

  // Write session file
  const filePath = path.join(SESSIONS_DIR, \`\${sessionId}.json\`);
  fs.writeFileSync(filePath, JSON.stringify(sessionFile, null, 2), "utf-8");
}

async function handleSessionEnd(payload) {
  const sessionId = payload.session_id;

  // Remove session file
  const filePath = path.join(SESSIONS_DIR, \`\${sessionId}.json\`);
  try {
    fs.unlinkSync(filePath);
  } catch {
    // File may not exist, ignore
  }

  // Remove events file
  const eventsPath = path.join(SESSIONS_DIR, \`\${sessionId}.events.jsonl\`);
  try {
    fs.unlinkSync(eventsPath);
  } catch {
    // File may not exist, ignore
  }
}

async function handlePermissionRequest(payload) {
  const sessionId = payload.session_id;

  // Ensure sessions directory exists
  if (!fs.existsSync(SESSIONS_DIR)) {
    fs.mkdirSync(SESSIONS_DIR, { recursive: true });
  }

  // Create event entry
  const event = {
    type: "permission_request",
    toolUseId: payload.tool_use_id,
    toolName: payload.tool_name,
    toolInput: payload.tool_input,
    permissionMode: payload.permission_mode,
    timestamp: new Date().toISOString(),
  };

  // Append to events JSONL file
  const eventsPath = path.join(SESSIONS_DIR, \`\${sessionId}.events.jsonl\`);
  fs.appendFileSync(eventsPath, JSON.stringify(event) + "\\n", "utf-8");
}

async function main() {
  // Read payload from stdin
  const stdinData = await readStdin();

  let payload;
  try {
    payload = JSON.parse(stdinData);
  } catch {
    // Invalid JSON, exit silently
    process.exit(0);
  }

  const hookName = payload.hook_event_name;

  switch (hookName) {
    case "SessionStart":
      await handleSessionStart(payload);
      break;
    case "SessionEnd":
      await handleSessionEnd(payload);
      break;
    case "PermissionRequest":
      await handlePermissionRequest(payload);
      break;
    default:
      // Unknown hook, exit silently
      break;
  }
}

main().catch(() => {
  // Exit silently on any error to not disrupt Claude Code
  process.exit(0);
});
`;
